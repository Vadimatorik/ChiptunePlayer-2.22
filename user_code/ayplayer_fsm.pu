@startuml

[*] --> start

state "wdt_init" as start {
start: Инициализация сторожевого таймера.
}

start --> s1: 0

state "gpio_init" as s1 {
s1: Инициализация всех используемых выводов.
s1: Подача тактового сигнала на порты, выводы в которых инициализируются,
s1: осуществляется автоматически.
}

s1 --> s2 : 0

state "rcc_init" as s2 {
s2: Инициализируем RCC модуль.

STEP_1 --> STEP_2 : Инициализация не удалась по\nвине поврежденного HSE
STEP_2 --> STEP_3 : Инициализация не удалась по\nвине поврежденного PLL

STEP_1 --> STEP_4 : Инициализация не удалась по\nвине поврежденного PLL

STEP_1 --> SUCCESS : Успешная\nинициализация
STEP_2 --> SUCCESS : Успешная\nинициализация
STEP_3 --> SUCCESS : Успешная\nинициализация
STEP_4 --> SUCCESS : Успешная\nинициализация

SUCCESS: Инициализация прошла успешно. 
SUCCESS: Возвращается 0.

STEP_3 --> FAIL : Провал\nинициализации.
STEP_4 --> STEP_3 : Инициализация не удалась по\nвине поврежденного HSE

FAIL: Полный провал
FAIL: конфигурации тактирования.
FAIL: Возвращается 1.

STEP_1: Попытка запустить тактирование со следующими параметрами:
STEP_1: Источник: внешний резонатор на 16 МГц (HSE).
STEP_1: PCLK:  120 МГц\t\tAHB1:  120 МГц\tAPB2:  60 МГц\tAPB1:  30 МГц

STEP_2: Попытка запустить 
STEP_2: тактирование со следующими 
STEP_2: параметрами:
STEP_2: Источник: внутренняя RC-цепь (HSI).
STEP_2: PCLK:  120 МГц
STEP_2: AHB1:  120 МГц
STEP_2: APB2:  60 МГц
STEP_2: APB1:  30 МГц

STEP_3: Попытка запустить 
STEP_3: тактирование со следующими
STEP_3: параметрами:
STEP_3: Источник: внутренняя RC-цепь (HSI).
STEP_3: PCLK:  16 МГц.
STEP_3: AHB1:  16 МГц.
STEP_3: APB2:  16 МГц.
STEP_3: APB1:  16 МГц.

STEP_4: Попытка запустить 
STEP_4: тактирование со следующими
STEP_4: параметрами:
STEP_4: Источник: внешний HSE.
STEP_4: PCLK:  16 МГц.
STEP_4: AHB1:  16 МГц.
STEP_4: APB2:  16 МГц.
STEP_4: APB1:  16 МГц.
}

s2 --> f1 : 1

state "rcc_falling" as f1 {
f1: RCC не смог инициализироваться 
f1: ни в одной из ниже 
f1: перечисленных конфигураций:
f1: 1.\tИсточник: внешний резонатор на 16 МГц.
f1: \tPCLK:\t120 МГц.
f1: \tAHB1:\t120 МГц.
f1: \tAPB2:\t60 МГц.
f1: \tAPB1:\t30 МГц.

f1: 2. Источник: внутренняя RC-цепь.
f1: \tPCLK:\t120 МГц.
f1: \tAHB1:\t120 МГц.
f1: \tAPB2:\t60 МГц.
f1: \tAPB1:\t30 МГц.

f1: 3. Источник: внутренняя RC-цепь.
f1: \tPCLK:\t16 МГц.
f1: \tAHB1:\t16 МГц.
f1: \tAPB2:\t16 МГц.
f1: \tAPB1:\t16 МГц.

f1: 4. Источник: внешний HSE.
f1: \tPCLK:\t16 МГц.
f1: \tAHB1:\t16 МГц.
f1: \tAPB2:\t16 МГц.
f1: \tAPB1:\t16 МГц.

f1: Метод вызывает программную перезагрузку.
f1: Поскольку транзистор подачи питания не 
f1: был удержан программно (удерживается 
f1: зажатием клавиши включения), то после
f1: отпускания плата будет обесточена.
}

s2 --> s3: 0

state "debug_uart_init" as s3 {
s3: Инициализируем UART, который 
s3: будет отдан в распоряжение logger-а.
s3: Подача тактового сигнала 
s3: происходит автоматически.
s3: DMA не задействуется.
}

s3 --> s4 : 0

state "nvic_init" as s4 {
s4: Настраиваем приоритеты 
s4: прерываниям и разрешаем последние.
}

s4 --> s5 : 0

state "spi_init" as s5 {
s5: Инициализируется 3 SPI.
s5: Подача тактового сигнала 
s5: на используемые SPI модули
s5: происходит автоматически.
s5: Используемые DMA 
s5: конфигурируются автоматически.
}

s5 --> fspi : 1

state "spi_falling" as fspi {
fspi: Инициализация какого-то 
fspi: из блоков SPI была неудачна.
fspi: Микроконтроллер будет 
fspi: программно перезагружен.
}

@enduml